__前言__
之前的文章尤其是讲解GC的时候提到了很多的概念，比如内存溢出和内存泄露、并行与并发、Client模式和Server模式、Minor GC和Full GC，本文详细讲解下这些概念的区别。

内存溢出和内存泄露的区别
__1、内存溢出__

内存溢出指的是程序在申请内存的时候，没有足够大的空间可以分配了。

__2、内存泄露__

内存泄露指的是程序在申请内存之后，没有办法释放掉已经申请到内存，它始终占用着内存，即被分配的对象可达但无用。内存泄露一般都是因为内存中有一块很大的对象，但是无法释放。

从定义上可以看出，内存泄露终将导致内存溢出。

注意，定位虚拟机问题内存问题的时候第一步就是要判断到底是内存溢出还是内存泄露，前者好判断，跟踪堆栈信息就可以了；后者比较复杂一点，一般都是老年代中的大对象没释放掉，要通过各种办法找出老年代中的大对象没有被释放的原因。

__并行和并发的区别__
这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，可以这么理解这两个名词：

1、并行Parallel

多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

2、并发Concurrent

指用户线程与垃圾收集线程同时执行（但并不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上

__Minor GC和Full GC的区别__
1、新生代GC（Minor GC）

指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快

2、老年代GC（Major GC/Full GC）

指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上

Client模式和Server模式的区别
部分商用虚拟机中，Java程序最初是通过解释器对.class文件进行解释执行的，当虚拟机发现某个方法或代码块运行地特别频繁的时候，就会把这些代码认定为热点代码Hot Spot Code（这也是我们使用的虚拟机HotSpot名称的由来）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器叫做即时编译器（Just In Time Compiler，即JIT编译器）。JIT编译器并不是虚拟机必需的部分，Java虚拟机规范并没有要求要有JIT编译器的存在，更没有限定或指导JIT编译器应该如何去实现。但是，JIT编译器性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键指标之一。

__解释器和编译器其实和编译器各有优势：__

1、当程序需要迅速启动和执行的时候，解释器可以先发挥作用，省去编译的时间，立即执行

2、在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率

我们使用的HotSpot中内置了两个JIT编译器，即C1编译器和C2编译器，默认采用的是解释器和一个编辑器配合的方式进行工作。HotSpot在启动的时候会根据自身版本以及宿主机器的硬件性能自动选择运行模式，比如会检测宿主机器是否为服务器、比如J2SE会检测主机是否有至少2个CPU和至少2GB的内存。

1、如果是，则虚拟机会以Server模式运行，该模式与C2编译器共同运行，更注重编译的质量，启动速度慢，但是运行效率高，适合用在服务器环境下，针对生产环境进行了优化

2、如果不是，则虚拟机会以Client模式运行，该模式与C1编译器共同运行，更注重编译的速度，启动速度快，更适合用在客户端的版本下，针对GUI进行了优化

有两种方法查看虚拟机是运行在Client模式下还是Server模式下：

1、在程序命令行运行“java -version”命令，查看的是你本地安装的虚拟机是信息



2、比如我们用Eclipse或者MyEclipse运行程序，一般使用的都是工具自带的JRE，虚拟机并不是本地安装的虚拟机。这时候怎么办呢，可以通过在程序中运行下面的语句来查看虚拟机信息
```java
System.out.println(System.getProperty("java.vm.name"));
```
我这里的运行结果是
Java HotSpot(TM) 64-Bit Server VM
当然要改变虚拟机运行的模式也可以，只需要改jvm.cfg就可以了。我们可以从以下几个地方找到jvm.cfg：

32位的JDK的文件路径是  JAVA_HOME/jre/lib/i386/jvm.cfg
64位的JDK的文件路径是  JAVA_HOME/jre/lib/amd64/jvm.cfg
MyEclipse在 …/Common/binary/com.sun.java.jdk.win32.x86_64_1.6.0.013/jre/lib/amd64/jvm.cfg
目前64位只支持Server模式，文件内容都是一样的，上面的注释不去管它，剩下的就是这些：

```java
-server KNOWN
-client IGNORE
-hotspot ALIASED_TO -server
-classic WARN
-native ERROR
-green ERROR
```
由于我的电脑装的是64位JDK，所以是“-client INGORE”。同时支持Server模式和Client模式的，应该是“-server KNOWN”和“-client KNOWN”，一般只需要变更这两个配置的先后顺序即可，但是前提是JAVA_HOME/jre/bin目录下同时存在server和client两个文件夹，分别对应着各自的虚拟机，缺少一个，切换后就会报错
